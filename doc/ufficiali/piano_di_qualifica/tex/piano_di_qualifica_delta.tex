\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{graphicx}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[italian]{babel}
\usepackage[colorlinks=true,linkcolor=black]{hyperref}

\renewcommand{\headrulewidth}{0.6pt}
\renewcommand{\footrulewidth}{0.6pt}
% impostazione dello stile per le pagine interne del documento
\lhead{\leftmark}
\chead{}
\rhead{\includegraphics[scale=0.15]{logo.png} }
\lfoot{Piano di Qualifica (Delta)}
\cfoot{}
\rfoot{\thepage \ di \pageref{LastPage}}
% ridefinizione dello stile plain per il frontespizio
\fancypagestyle{plain}{
\fancyhf
}
% impostazione dello stile per l'indice
\fancypagestyle{indice}{
\lhead{\leftmark}
\chead{}
\rhead{\includegraphics[scale=0.15]{logo.png}}
\lfoot{Piano di Qualifica (Delta)}
\cfoot{}
\rfoot{}
}
\headheight = 46pt
%definizione del comando "\modfiche" per la creazione del diario delle modifiche
\newcommand{\modifiche} 
{
\newpage
\begin{center}
\textbf{Diario delle modifiche} \\
\bigskip
\begin{tabular}{|c|c|p{0.61\textwidth}|}
\hline
\textsc{Data} & \textsc{Versione} & \textsc{Modifica} \\
\hline
\hline
\textit{04-06-2009} & Delta & Aggiunte le descrizioni dei tool di misurazione delle metriche  \\
\hline
\end{tabular}
\end{center}
}
%definizione del comando "\info" per la creazione delle informazioni del documento
\newcommand{\info} {
\bigskip
\begin{tabbing}
	\hspace*{0.3\textwidth} \= \hspace*{0.5\textwidth} \kill
	\parbox{0.3\textwidth}{\textbf{Verifica: }} \> \parbox{0.5\textwidth}{Scarpa Davide} \\
	\parbox{0.3\textwidth}{\textbf{Approvazione: }} \> \parbox{0.5\textwidth}{Beggiato Andrea} \\
	\parbox{0.3\textwidth}{\textbf{Stato: }} \> \parbox{0.5\textwidth}{Formale} \\
	\parbox{0.3\textwidth}{\textbf{Uso: }} \> \parbox{0.5\textwidth}{Esterno} \\
	\parbox{0.3\textwidth}{\textbf{Distribuzione: }} \> \parbox{0.5\textwidth}{QuiXoft} \\
	\> \parbox{0.5\textwidth}{Rossi Francesca} \\
	\> \parbox{0.5\textwidth}{Vardanega Tullio} \\
	\> \parbox{0.5\textwidth}{Conte Renato} \\
\end{tabbing}
}
%definizione del comando "\frontespizio" per la creazione del frontespizio
\newcommand{\frontespizio} {
\thispagestyle{plain}
\title{\begin{Huge}\textsc{Progetto SIGEOL}\end{Huge} \\ \textit{Piano di Qualifica \\ (Delta)}}
\author{Redazione: Carlo Scortegagna, Barbiero Mattia}
\maketitle
\medskip
\begin{center}
\includegraphics[scale=0.5]{logo.png} \\
\textit{quixoft.sol@gmail.com} \\
\end{center}
\medskip
\info
\begin{center}
\textbf{Sommario} \\
Aggiornamento del Piano di Qualifica per il progetto ''SIGEOL'', contenente solamente le modifiche rispetto al documento consegnato alla Revisione di Qualifica.
\end{center}
\newpage
}
%definizione del comando "\indice" per la creazione dell'indice
\newcommand{\indice} {
\thispagestyle{indice}
\tableofcontents
\newpage
}
\pagestyle{fancy}
\begin{document}
\frontespizio
\indice
\setcounter{page}{1}
\section{Introduzione}
\subsection{Scopo del documento}
Lo scopo del presente documento è di notificare gli aggiornamenti che sono stati apportati rispetto al documento consegnato alla precedente revisione.

Tali modifiche rappresentano il proseguimento delle attività di verifica e validazione del materiale prodotto e la descrizione degli \underline{ambienti di prova} e di \underline{collaudo}.
\section{Resoconto delle attività di verifica}
Ogni risultato ottenuto dalle attività di verifica, validazione e qualifica dovrà essere attentamente elencato in questa sezione, in modo da assicurare che tutti i problemi e le relative soluzioni siano tracciate per garantire la massima qualità possibile del prodotto finale.
\subsection{Tracciamento componenti - requisiti}

\subsection{Dettaglio delle verifiche tramite test}
Per l'esecuzione delle attività di verifica tramite test verranno utilizzati i moduli e le classi rese disponibili dal framework Rails, e più precisamente ogni test di unità dovrà estendere la classe ActiveSupport::TestCase ed ogni test funzionale dovrà estendere la classe ActionController::TestCase.
\subsubsection{Functional Tests}
Nello sviluppo di un'applicazione tramite il framework Rails, i test funzionali (functional tests) sono specifici per la verifica degli elementi appartenenti alla componente Controller. Dato che gli unit tests sono stati effettuati tramite istanze reali, il team QuiXoft ha scelto di utilizzare la strategia dei Mock objects per la verifica delle azioni presenti nei controller.

Ogni classe che implementa un insieme di test per un particolare controller dovrà essere denominata \verb|NomeControllerTest| ed essere salvata su di un file chiamato \verb|nome_controller_controller_test.rb| all'interno della directory \verb|test/functional|.

Un esempio di functional test per il controller \verb|sessions| è dato dalla seguente porzione di codice: \\
nel file \verb|sessions_controller_test.rb|
\begin{verbatim}
class SessionsControllerTest < ActionController::TestCase

  test "Guest usa New" do
    get :new
    assert_template "new"
    assert_response :success
  end

  test "Immissione di email e password validi" do
    user = stub(:id => :an_id, :mail => "a_mail",
                :password => "a_password")
    User.stubs(:authenticate).returns(user)
    user.stubs(:active?).returns(true)
    post :create, :mail => user.mail, :password => user.password
    assert_equal session[:user_id], :an_id
    assert_redirected_to timetables_url
  end
end
\end{verbatim}
\subsection{Metriche}
Il progetto `Sigeol`, al termine della fase di programmazione, è stato testato con numerosi strumenti dedicati a Ruby on Rails con lo scopo di generare delle metriche precise che indichino il livello qualitativo del codice prodotto dal team QuiXoft.

E' stato scelto di utilizzare Metric\_Fu 1.0.2, raccolta di gemme per Ruby on Rails scaricabile da http://metric-fu.rubyforge.org/

Nei capitoli seguenti saranno analizzate una ad una tutte le metriche utilizzate:
\subsubsection{Rcov}
Lo strumento Rcov è stato usato per misurare la copertura dei test sul codice. Il team QuiXoft utilizzerà la metrica C0, ovvero sarà controllata la copertura di ogni istruzione, e quindi di ogni riga di codice dell'intero progetto.

La situazione di copertura dei test sul codice è riportato nel file \textit{coverage.pdf} allegato al presente documento.

\begin{large}INSERIRE I RISULTATI DI RCOV\end{large}
\subsubsection{Flay}
Qualsiasi progetto Rails dovrebbe seguire il più possibile il principio DRY: Don't Repeat Yourself.
Anche se questo deve essere inteso come principio generale, dovremmo anche evitare di avere ripetizioni all’interno del medesimo file.

Flay permette di tenere sotto controllo le duplicazioni, analizzando le “similarità strutturali” (branch, cicli, etc) presenti nel codice: se due parti di codice sono simili allora potrebbero essere buone candidate per un refactoring.

Il risultato di tale metrica di analisi si può consultare nel file \textit{flay.html} allegato al presente documento.

Analizzando i risultati si possono notare numerose ripetizioni: la maggior parte non sono tuttavia evitabili, in quanto diversi metodi all'interno degli stessi controller hanno un redirect alla stessa pagina, e per forza di cose il codice che effettua il redirect deve essere ripetuto.
Nonostante ciò, la quantità di ripetizioni non è stata ritenuta preoccupante dai membri del team QuiXoft, ne sono stati rilevati eventuali problemi per la futura manutenzione del codice.
\subsubsection{Flog}
Lo strumento Flog applica una metrica ABC al codice del progetto `Sigeol` al fine di misurarne la complessità.
La metrica ABC misura la distanza euclidea dall’origine nello spazio tridimensionale formato da:
\begin{itemize}
 \item Assignments
 \item Branch
 \item Condition
\end{itemize}
Più il codice risulta “lineare” minore sarà il valore di tale metrica ad esso applicato (e tenderà ad essere più gestibile). Al contrario, nel caso di codice ricco di cicli, sottocicli e diversi branch, mostrerebbe un valore elevato, indicando un codice, almeno in teoria, più soggetto a bachi.

Il risultato di tale metrica di analisi si può consultare nel file \textit{flog.html} allegato al presente documento.

La seguente tabella, messa a disposizione degli sviluppatori di Flog, indica la scala di valori con cui misurare la bontà dei risultati, prendendo in esame il punteggio per metodo (seconda colonna del file allegato):

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textsc{Punteggio} & \textsc{Risultato} \\
\hline
\hline
\textit{0 - 10} & Ottimo  \\
\hline
\textit{11 - 20} & Buono  \\
\hline
\textit{21 - 40} & Abbastanza buono (da valutare un possibile refactoring)  \\
\hline
\textit{41 - 60} & Accettabile ma sconsigliato  \\
\hline
\textit{60 - 100} & Pericoloso  \\
\hline
\textit{100 o più} & Non accettabile  \\
\hline
\end{tabular}
\end{center}
Osservando i risultati ottenuti, si può notare che solamente 2 classi rientrano nella fascia 21-40, mentre tutte le altre possono considerarsi buone o ottime. Le 2 classi imputate sono teacher\_controller e classroom\_controller: ne è stato valutato un refactoring, ma si è deciso di mantenerle cosi come sono in quanto la loro complessità è stata ritenuta perfettamente accettabile dai membri del team QuiXoft.
\subsubsection{Saikuro}
Saikuro è uno strumento per misurare la complessità ciclomatica, metrica strutturale relativa al flusso di controllo di un programma che rappresenta la sua complessità logica, cioè lo sforzo per realizzarlo e comprenderlo.

Il risultato di tale metrica di analisi si può consultare nel file \textit{saikuro.html} allegato al presente documento.

La seguente tabella indica la scala di punteggi con cui valutare i risultati ottenuti:
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textsc{Punteggio} & \textsc{Risultato} \\
\hline
\hline
\textit{0 - 10} & Ottimo  \\
\hline
\textit{11 - 20} & Buono  \\
\hline
\textit{21 - 40} & Sufficiente  \\
\hline
\textit{41 o più} & Insufficiente  \\
\hline
\end{tabular}
\end{center}
Esaminando il file allegato, si può notare come tutti i metodi rientrino nelle prime 2 categorie, indicando una limitata complessità ciclomatica, a tutto vantaggio della facilità di gestione e di manutenzione del codice del progetto SIGEOL.
\subsubsection{Reek}
Reek è uno strumeto di analisi del codice che ci dice se e dove compaiono pattern “sospetti”, come ad esempio:
\begin{itemize}
 \item metodi troppo lunghi
 \item classi troppo ampie
 \item nomi criptici
 \item liste di paramentri eccessivamente lunghe
 \item duplicazioni
\end{itemize}
Il risultato di tale metrica di analisi si può consultare nel file \textit{reek.html} allegato al presente documento.

Al termine della fase di programmazione molte parti di codice del progetto `Sigeol` sono state modificate e ottimizzate tenendo conto delle considerazioni nate consultando il risultato di Reek, ma molte delle segnalazioni ancora presenti nel file allegato sono state ritenute poco significative o addirittura in contraddizione con scelte fatte durante lo sviluppo: si è ritenuta quindi irrealizzabile l'idea di eliminare completamente tutti i problemi segnalati da questo strumento.
\subsubsection{Roodi}
Roodi è l’acronimo di “Ruby Object Oriented Design Inferometer”. E’ uno strumento che analizza il nostro codice relativamente a:
\begin{itemize}
 \item nomi delle classi
 \item nomi dei metodi
 \item complessità ciclomatica (sia a livello di metodi che di blocchi)
 \item blocchi “rescue” vuoti
 \item cicli del tipo “for”
 \item lunghezza dei metodi
\end{itemize}
Il risultato di tale metrica di analisi si può consultare nel file \textit{roodi.html} allegato al presente documento.

Roodi segnala parecchi metodi con lunghezza superiore alle 20 righe: il team QuiXoft ha ritenuto che tale valore sia piuttosto limitante, e per questo ha dato un peso relativamente basso a tale segnalazione. Il numero di righe per metodo non supera mai comunque le 40 righe, valore ritenuto un ottimo compromesso per quanto riguarda la leggibilità e la manutenibilità del codice.
\subsubsection{Churn}
Churn tiene traccia dei file soggetti a maggiori modifiche. Un file il cui contenuto cambia spesso è un sintomo di probabile necessità di refactoring: forse è necessario rivedere le entità definite, oppure introdurre un diverso design pattern.
Churn inferisce i cambiamenti attraverso l’analisi dei log dei Subversion.

Il risultato di tale metrica di analisi si può consultare nel file \textit{churn.html} allegato al presente documento.

Anche in questo caso il teacher\_controller risulta essere il file modificato più volte: il numero delle modifiche resta comunque accettabile, ed è giustificato dalla notevole complessità delle operazioni che tale controller è tenuto a gestire.
Tutti gli altri file sono stati limitatamente modificati, indice di una corretta progettazione.
\modifiche
\end{document}
